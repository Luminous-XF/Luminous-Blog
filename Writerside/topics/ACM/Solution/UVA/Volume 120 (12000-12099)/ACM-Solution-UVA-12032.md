# UVA 12032 - The Monkey and the Oiled Bamboo

## 🚀 原题地址

[UVA 12032 - The Monkey and the Oiled Bamboo](https://onlinejudge.org/external/120/12032.pdf)

## 🏷️ 题目类型

二分查找

## 📜 题目

**题意**

是时候回忆一下老派数学中那个灾难性的时刻了。没错，就是那道猴子爬涂了油的竹子的小数学题。题目是这样的：一只猴子试图爬到一根涂了油的竹子的顶端。当它向上爬
$3$ 英尺时，会下滑 $2$ 英尺。向上爬 $3$ 英尺需要 $3$ 秒。下滑 $2$ 英尺需要 $1$ 秒。如果竹子高 $12$
英尺，猴子爬到顶端需要多长时间？”当我拿到这个问题时，我还很认真对待。但过了一会儿，我想的不是解题而是杀了那只猴子！对于给竹子涂油的人，我有完全不同的打算（！）。现在，我们这些出题者，也遇到了类似涂了油的竹子的情况。所以，我们觉得我们能比传统的猴子做得更好。于是，我先试了一下。我跳起来爬了
$3.5$英尺（比猴子强！哼！）但紧接着我就滑倒摔到地上了。之后我就什么都不记得了，等我醒来，发现自己躺在床上，周围是出题者们焦虑的脸。所以，就像以前一样，猴子和涂了油的竹子赢了。所以，我又制定了另一个计划（不知怎么的，我就是想打败那只猴子），我拿了一个梯子而不是竹子。最初我在地面上。每次跳跃我只能从当前的梯级（或地面）跳到下一个梯级（不能跳过梯级）。最初我设定了我的力量系数
$k$。$k$ 的意思是，在任何一次跳跃中，我不能跳超过 $k$ 英尺。并且如果我恰好跳了 $k$ 英尺，$k$ 就减 $1$。但如果我跳的小于 $k$ 英尺，$k$
保持不变。例如，假设从地面开始梯级的高度分别是 $1、6、7、11、13$，$k$ 为 $5$。现在的步骤是：$1$. 从地面跳到第 $1$ 个梯级跳了 $1$
英尺（从地面到$1$）。因为我跳的小于 $k$ 英尺，$k$ 保持为 $5$。$2$. 跳到下一个梯级跳了$5$ 英尺（从 $1$ 到 $6$）。所以，$k$ 变为 $4$。$3$.
跳到第 $3$ 个梯级跳了 $1$ 英尺（从$6$ 到 $7$）。所以，$k$ 保持为 $4$。$4$. 跳到第 $4$ 个梯级跳了 $4$ 英尺（从 $7$ 到 $11$）。这次 $k$ 变为 
$3$。$5$. 跳到第 $5$ 个梯级跳了 $2$ 英尺（从 $11$ 到$13$）。所以，$k$ 保持为 $3$。现在给你从地面开始梯子梯级的高度，你需要找到最小的力量系数 $k$，使得我能够到达顶部梯级。

**输入**

输入以一个整数 $T$ ($T \leq 500$) 开始，表示测试用例的数量。每个用例以一行包含一个整数 $n$ 开始，表示梯子的横档数量。下一行包含 $n$ 个用空格分隔的整数，
$r_{1}, ~r_{2},~\cdots,~r_{n} ~ (1 ~\leq r_{1} ~\lt r_{2} ~\lt ~\cdots ~\lt~  r_{n} ~\leq 10^{7}$) 表示从地面起横档的高度。对于所有情况，$1 \leq n \leq 10$，除了 $5$ 个情况，其中 $10 \lt n \leq 10^{5}$。

**输出**

对于每种情况，打印情况编号和如上所述的 $k$ 的最小值。

**样例输入**

```text
2
5
1 6 7 11 13
4
3 9 10 14
```

**样例输出**

```text
Case 1: 5
Case 2: 6
```

## 🔍 分析

对 $k$ 进行二分查找。


## 💡 代码

```C++
//
// Created by Luminous on 2024/10/18.
// https://onlinejudge.org/external/120/12032.pdf
//

#pragma GCC optimize(3)

#include <bits/stdc++.h>
using namespace std;

#define endl "\n"


const int MAX_N = 1e5 + 10;

int a[MAX_N];

bool check(int n, int k) {
    int pre = 0;
    for (int i = 0; i < n; i++) {
        if (a[i] - pre > k) return false;
        if (a[i] - pre == k) {
            k--;
        }
        pre = a[i];
    }

    return true;
}

void solve(int testCase) {
    int n;
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> a[i];
    }

    long long left = 0, right = *max_element(a, a + n);
    while (left < right) {
        int mid = left + right >> 1;
        if (check(n, mid)) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }

    cout << "Case " << testCase << ": ";
    cout << right << endl;
}

int main() {

    ios::sync_with_stdio(false);

    int T = 1;
    cin >> T;
    for (int i = 1; i <= T; i++) {
        solve(i);
    }

    return 0;
}
```